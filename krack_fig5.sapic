/*******************************************************************************
	Formal Modeling of KRACK attacks and verification of mitigations
	
	Attack against the 4-way handshake, when the victim accepts a plaintext
	message 3 retransmission if sent instantly after the first one
	
	Notation:
	
	pmk = Pairwise Master Key
	ptk = Pairwise Transient Key, composed of:
		kck = Key Confirmation Key
		kek = Key Encryption Key
		tk = Temporal Key
	gtk = Group Transient Key
	
*******************************************************************************/

theory Krack_fig5
begin

builtins:
	symmetric-encryption,
	multiset

functions:
	true/0,
	CalcPTK/1,
	mic/2,
	kck/1,
	kek/1,
	tk/1,
	verifyMic/3

equations: 
	verifyMic(mic(m,k), m, k) = true

predicates:
	Equal(x,y) <=> x = y
	

let Supplicant =
	new S_id;
	out(S_id);

	!(
		//Initial 4-way handshake
		new ~tid;
		let pat_msg1_contents = <'Header1', r, ANonce> in
		in(pat_msg1_contents);

		new ~SNonce;
		let tptk = CalcPTK(<pmk, ANonce, ~SNonce>) in
		event ComputePTK(~tid,tptk);
		let msg2_contents = <'Header2', r, ~SNonce> in
		out(<msg2_contents, mic(msg2_contents, kck(tptk))>);

		let msg3_contents = <'Header3', r+'1', ANonce, senc(gtk1, kek(tptk))> in
		in(<msg3_contents, mic(msg3_contents, kck(tptk))>);
		
		let ptk = tptk in
		
		((
			let msg4_contents = <'Header4', r+'1'> in
			out(<msg4_contents, mic(msg4_contents, kck(ptk))>);

			event InstallS(S_id, ptk, gtk1);
			event SuplicantEnd(S_id, ANonce, ~SNonce, ptk, gtk1)
		) + 
		(
			let msg3_rtx_contents = <'Header3', r+'1'+'1', ANonce, senc(gtk2, kek(tptk))> in
			in(<msg3_rtx_contents, mic(msg3_rtx_contents, kck(tptk))>);
			
			let ptk = tptk in
			
			let msg4_contents = <'Header4', r+'1'> in
			out(<msg4_contents, mic(msg4_contents, kck(ptk))>);

			event InstallS(S_id, ptk, gtk1);
			event SuplicantEnd(S_id, ANonce, ~SNonce, ptk, gtk1);

			// Uncomment to apply countermeasure
			//if ~ptk2 = ~ptk1 then
			//	0
			//else
				let msg4_rtx_contents = <'Header4', r+'1'+'1'> in
				out(senc(<msg4_rtx_contents, mic(msg4_rtx_contents, kck(ptk))>,tk(ptk)));
			
				event InstallS(S_id, ptk, gtk2);
				event SuplicantEnd(S_id, ANonce, ~SNonce, ptk, gtk2)
		))
	)
	

let Authenticator =
	!(
		new ~r;
		new ~ANonce;
		
		let pat_msg1_contents = <'Header1', ~r, ~ANonce> in
		out(pat_msg1_contents);

		let ptk = CalcPTK(<pmk, ~ANonce, SNonce>) in
		let msg2_contents = <'Header2', ~r, SNonce> in
		in(<msg2_contents, mic(msg2_contents, kck(ptk))>);
		
		new ~gtk;
		event InstallAgtk(~gtk);

		let msg3_contents = <'Header3', ~r+'1', ~ANonce, senc(~gtk, kek(ptk))> in
		out(<msg3_contents, mic(msg3_contents, kck(ptk))>);

		((
			let msg4_contents = <'Header4', ~r+'1'> in
			in(<msg4_contents, mic(msg4_contents, kck(ptk))>);
			
			event InstallAptk(ptk);
			event AuthenticatorEnd(~ANonce, SNonce, ptk, ~gtk)
		)+
		(
			let msg3_rtx_contents = <'Header3', ~r+'1'+'1', ~ANonce, senc(~gtk, kek(ptk))> in
			out(<msg3_rtx_contents, mic(msg3_rtx_contents, kck(ptk))>);
			
			// Msg4(r+1) could have been received here (ignored)
			
			let msg4_rtx_contents = <'Header4', ~r+'1'+'1'> in
			in(senc(<msg4_rtx_contents, mic(msg4_rtx_contents, kck(ptk))>,tk(ptk)));

			// Msg4(r+1) could have been received here (ignored)
			
			event InstallAptk(ptk);
			event AuthenticatorEnd(~ANonce, SNonce, ptk, ~gtk)
		))
	)

	
new pmk; (!Supplicant || Authenticator)


// Uncomment to apply countermeasure
//restriction Countermeasure1:
//	"All S ptk1 ptk2 gtk1 gtk2 #i #j. InstallS(S, ptk1, gtk1)@i & InstallS(S, ptk2, gtk2)@j ==> not(ptk1 = ptk2)"

// Uncomment to apply countermeasure
//restriction Countermeasure2:
//	"All S ptk1 ptk2 gtk1 gtk2 #i #j. InstallS(S, ptk1, gtk1)@i & InstallS(S, ptk2, gtk2)@j ==> not(gtk1 = gtk2)"


lemma Correctness1:
exists-trace
	"Ex a b c #i. InstallS(a,b,c)@i" 

lemma Correctness3:
exists-trace
	"Ex a #i. InstallAgtk(a)@i" 

lemma Correctness4:
exists-trace
	"Ex a #i. InstallAptk(a)@i"
	
lemma Correctness5:
exists-trace
	"Ex S_id ANonce SNonce ptk gtk #i. SuplicantEnd(S_id, ANonce, SNonce, ptk, gtk)@i"
	
lemma Correctness6:
exists-trace
	"Ex ANonce SNonce ptk gtk #i. AuthenticatorEnd(ANonce, SNonce, ptk, gtk)@i"
	/* The KRACK attack does not exist */
lemma NoKrack:
	"All S ptk gtk1 #i . InstallS(S, ptk, gtk1)@i ==> not(Ex gtk2 #j. InstallS(S, ptk, gtk2)@j & j < i)" 


/* PTK/GTK is secret - It is not possible that the ptk/gtk has been installed  and the adversary knows it */
lemma SecretPtk:
 all-traces
    "All S ptk gtk #i. InstallS(S,ptk,gtk)@i  ==> (not (Ex #j. K(ptk)@j))"


lemma SecretGtk:
 all-traces
    "All S ptk gtk #i. InstallS(S,ptk,gtk)@i  ==> (not (Ex #j. K(gtk)@j))"

/* PTK is fresh*/
lemma FreshPtk: 
 all-traces
    "All tid1 tid2 ptk #i #j. ComputePTK(tid1,ptk)@i & ComputePTK(tid2,ptk)@j ==> (tid1=tid2)"



/* GTK accepted by one of the parties is the GTK calculated and forwarded by another */
lemma gtkRecdSameAsGenerated:
 all-traces
    "All S ptk gtk #i. InstallS(S,ptk,gtk)@i  ==> (Ex #j. InstallAgtk(gtk)@j & (j < i))"

end
